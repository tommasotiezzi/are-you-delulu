/* ============================================
   ARE YOU DELULU - Guy Detail Page
   ============================================ */

const GuyDetail = {
  currentGuy: null,
  currentProCons: [],
  
  async render(guyId) {
    console.log('[GuyDetail] render() called, guyId:', guyId);
    
    const renderId = App.getRenderId();
    
    App.renderShell(`
      <div class="page-loader">
        <div class="spinner"></div>
      </div>
    `, { showBack: true });
    
    try {
      // Fetch guy
      console.log('[GuyDetail] Fetching guy from database...');
      const { data: guy, error: guyError } = await db
        .from('guys')
        .select('*')
        .eq('id', guyId)
        .single();
      
      // Check if we navigated away
      if (!App.shouldRender(renderId)) {
        console.log('[GuyDetail] Stale render, aborting');
        return;
      }
      
      console.log('[GuyDetail] Guy fetch result:', { guy, guyError });
      
      if (guyError || !guy) {
        Utils.showToast('Ragazzo non trovato', 'error');
        window.location.hash = '#/dashboard';
        return;
      }
      
      this.currentGuy = guy;
      
      // Fetch pro_cons
      console.log('[GuyDetail] Fetching pro_cons...');
      const { data: proCons, error: pcError } = await db
        .from('pro_cons')
        .select('*')
        .eq('guy_id', guyId)
        .order('position', { ascending: true });
      
      console.log('[GuyDetail] Pro_cons fetch result:', { proCons, pcError });
      
      // Check again after second fetch
      if (!App.shouldRender(renderId)) {
        console.log('[GuyDetail] Stale render, aborting');
        return;
      }
      
      this.currentProCons = proCons || [];
      
      const pros = this.currentProCons.filter(p => p.type === 'pro');
      const cons = this.currentProCons.filter(p => p.type === 'con');
      const score = Utils.calculateScore(this.currentProCons);
      const category = Utils.getScoreCategory(score.percentage, score.hasDealbreaker);
      const verdict = Utils.getRandomVerdict(category);
      
      const content = `
        <div class="guy-detail-header">
          <div class="guy-detail-title">
            <h1 class="page-title">${Utils.escapeHtml(guy.name)}</h1>
            ${guy.how_met ? `<span class="badge badge-secondary">${Utils.getHowMetLabel(guy.how_met)}</span>` : ''}
          </div>
          <div class="guy-detail-actions">
            <button class="btn btn-secondary" onclick="ChatWidget.openForGuy('${guyId}', '${Utils.escapeHtml(guy.name)}')">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
              </svg>
              Chatta con Bea
            </button>
            <button class="btn btn-ghost" onclick="GuyDetail.deleteGuy('${guyId}')" title="Elimina">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
              </svg>
            </button>
          </div>
        </div>
        
        <div class="guy-detail-score">
          ${score.hasDealbreaker ? `
            <div class="guy-detail-dealbreaker">
              <span class="dealbreaker-icon">⚠️</span>
              <span class="dealbreaker-text">Dealbreaker</span>
            </div>
            <div class="guy-detail-score-verdict">${verdict}</div>
          ` : `
            <div class="guy-detail-score-percentage text-${category}">${score.percentage}%</div>
            <div class="guy-detail-score-verdict">${verdict}</div>
          `}
        </div>
        
        <div class="procon-columns">
          <div class="procon-column">
            <div class="procon-column-header pro">PRO (${pros.length})</div>
            <div class="procon-list" id="pros-list">
              ${pros.map(p => this.renderProConItem(p, guyId)).join('')}
              ${pros.length === 0 ? '<p class="text-secondary text-sm text-center">Nessun pro ancora</p>' : ''}
            </div>
            <div class="procon-add">
              <input type="text" class="procon-add-input" id="add-pro-input" placeholder="Aggiungi un pro..." data-type="pro" data-guy="${guyId}">
              <button class="procon-add-btn" onclick="GuyDetail.submitInput('add-pro-input')" title="Aggiungi">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="12" y1="5" x2="12" y2="19"></line>
                  <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
              </button>
            </div>
          </div>
          
          <div class="procon-column">
            <div class="procon-column-header con">CONTRO (${cons.length})</div>
            <div class="procon-list" id="cons-list">
              ${cons.map(c => this.renderProConItem(c, guyId)).join('')}
              ${cons.length === 0 ? '<p class="text-secondary text-sm text-center">Nessun contro ancora</p>' : ''}
            </div>
            <div class="procon-add">
              <input type="text" class="procon-add-input" id="add-con-input" placeholder="Aggiungi un contro..." data-type="con" data-guy="${guyId}">
              <button class="procon-add-btn" onclick="GuyDetail.submitInput('add-con-input')" title="Aggiungi">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <line x1="12" y1="5" x2="12" y2="19"></line>
                  <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
              </button>
            </div>
          </div>
        </div>
      `;
      
      App.renderShell(content, { showBack: true });
      this.bindEvents(guyId, pros, cons);
      
    } catch (err) {
      console.error('[GuyDetail] EXCEPTION:', err);
      Utils.showToast('Errore: ' + err.message, 'error');
    }
  },
  
  renderProConItem(item, guyId) {
    const weightLabel = Utils.getWeightLabel(item.type, item.weight);
    const weightOptions = item.type === 'pro' 
      ? [
          { value: 1, label: 'Meh ok' },
          { value: 3, label: 'Sì dai' },
          { value: 5, label: 'QUESTO SÌ' }
        ]
      : [
          { value: 1, label: 'Sopravvivo' },
          { value: 3, label: 'Non mi piace' },
          { value: 5, label: 'No proprio no' }
        ];
    
    const dealbreaker = item.type === 'con' ? `
      <button class="procon-item-dealbreaker ${item.is_dealbreaker ? 'active' : ''}" 
              onclick="GuyDetail.toggleDealbreaker('${item.id}', '${guyId}', ${!item.is_dealbreaker})"
              title="${item.is_dealbreaker ? 'Rimuovi dealbreaker' : 'Segna come dealbreaker'}">
        ⚠️
      </button>
    ` : '';
    
    return `
      <div class="procon-item" data-id="${item.id}">
        <span class="procon-item-text">${Utils.escapeHtml(item.text)}</span>
        <select class="procon-item-weight-select" onchange="GuyDetail.updateWeight('${item.id}', '${guyId}', this.value)">
          ${weightOptions.map(opt => `
            <option value="${opt.value}" ${item.weight === opt.value ? 'selected' : ''}>${opt.label}</option>
          `).join('')}
        </select>
        ${dealbreaker}
        <button class="btn btn-ghost btn-sm procon-item-delete" onclick="GuyDetail.deleteProCon('${item.id}', '${guyId}')">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
    `;
  },
  
  bindEvents(guyId, pros, cons) {
    document.querySelectorAll('.procon-add-input').forEach(input => {
      let debounceTimer = null;
      
      // Autocomplete on input
      input.addEventListener('input', (e) => {
        clearTimeout(debounceTimer);
        const text = input.value.trim();
        
        if (text.length < 2) {
          this.hideAutocomplete(input);
          return;
        }
        
        debounceTimer = setTimeout(() => {
          this.fetchAutocomplete(input, text, input.dataset.type, guyId);
        }, 300);
      });
      
      // Submit on Enter
      input.addEventListener('keypress', async (e) => {
        if (e.key === 'Enter' && input.value.trim()) {
          e.preventDefault();
          this.hideAutocomplete(input);
          
          const type = input.dataset.type;
          const text = input.value.trim();
          
          // Get current count for position
          const currentList = type === 'pro' ? pros : cons;
          const position = currentList.length;
          
          input.disabled = true;
          
          const { error } = await db
            .from('pro_cons')
            .insert({
              guy_id: guyId,
              type,
              text,
              weight: 3,
              position
            });
          
          if (error) {
            Utils.showToast('Errore nel salvataggio', 'error');
            input.disabled = false;
            return;
          }
          
          // Reload page
          this.render(guyId);
        }
      });
      
      // Hide autocomplete on blur (with delay for click)
      input.addEventListener('blur', () => {
        setTimeout(() => this.hideAutocomplete(input), 200);
      });
    });
  },
  
  async fetchAutocomplete(input, searchTerm, type, guyId) {
    const userId = Auth.getUser()?.id;
    if (!userId) return;
    
    const { data, error } = await db.rpc('get_autocomplete', {
      user_uuid: userId,
      search_term: searchTerm,
      entry_type: type,
      exclude_guy_id: guyId
    });
    
    if (error || !data || data.length === 0) {
      this.hideAutocomplete(input);
      return;
    }
    
    this.showAutocomplete(input, data, guyId);
  },
  
  showAutocomplete(input, suggestions, guyId) {
    // Remove existing dropdown
    this.hideAutocomplete(input);
    
    const dropdown = document.createElement('div');
    dropdown.className = 'autocomplete-dropdown';
    dropdown.innerHTML = suggestions.map(s => `
      <div class="autocomplete-item" data-text="${Utils.escapeHtml(s.text)}">
        <span>${Utils.escapeHtml(s.text)}</span>
        <span class="autocomplete-count">usato ${s.times_used}x</span>
      </div>
    `).join('');
    
    // Position below input
    const inputRect = input.getBoundingClientRect();
    dropdown.style.position = 'absolute';
    dropdown.style.top = (input.offsetTop + input.offsetHeight) + 'px';
    dropdown.style.left = input.offsetLeft + 'px';
    dropdown.style.width = input.offsetWidth + 'px';
    
    input.parentElement.style.position = 'relative';
    input.parentElement.appendChild(dropdown);
    
    // Handle click on suggestion
    dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
      item.addEventListener('mousedown', (e) => {
        e.preventDefault();
        input.value = item.dataset.text;
        this.hideAutocomplete(input);
        input.focus();
      });
    });
  },
  
  hideAutocomplete(input) {
    const existing = input.parentElement.querySelector('.autocomplete-dropdown');
    if (existing) existing.remove();
  },
  
  async deleteGuy(guyId) {
    if (!confirm('Sei sicura di voler eliminare questo ragazzo? Tutti i dati verranno persi.')) {
      return;
    }
    
    const { error } = await db
      .from('guys')
      .delete()
      .eq('id', guyId);
    
    if (error) {
      Utils.showToast('Errore durante l\'eliminazione', 'error');
      return;
    }
    
    Utils.showToast('Ragazzo eliminato', 'success');
    window.location.hash = '#/dashboard';
  },
  
  async deleteProCon(proConId, guyId) {
    const { error } = await db
      .from('pro_cons')
      .delete()
      .eq('id', proConId);
    
    if (error) {
      Utils.showToast('Errore durante l\'eliminazione', 'error');
      return;
    }
    
    // Reload page
    this.render(guyId);
  },
  
  // Submit input when clicking the + button
  async submitInput(inputId) {
    const input = document.getElementById(inputId);
    if (!input || !input.value.trim()) return;
    
    const type = input.dataset.type;
    const guyId = input.dataset.guy;
    const text = input.value.trim();
    
    // Get current count for position
    const currentList = this.currentProCons.filter(p => p.type === type);
    const position = currentList.length;
    
    input.disabled = true;
    
    const { error } = await db
      .from('pro_cons')
      .insert({
        guy_id: guyId,
        type,
        text,
        weight: 3,
        position
      });
    
    if (error) {
      Utils.showToast('Errore nel salvataggio', 'error');
      input.disabled = false;
      return;
    }
    
    // Reload page
    this.render(guyId);
  },
  
  // Update weight when dropdown changes
  async updateWeight(itemId, guyId, newWeight) {
    const { error } = await db
      .from('pro_cons')
      .update({ weight: parseInt(newWeight) })
      .eq('id', itemId);
    
    if (error) {
      Utils.showToast('Errore nell\'aggiornamento', 'error');
      return;
    }
    
    // Reload to update score
    this.render(guyId);
  },
  
  // Toggle dealbreaker status
  async toggleDealbreaker(itemId, guyId, newValue) {
    const { error } = await db
      .from('pro_cons')
      .update({ is_dealbreaker: newValue })
      .eq('id', itemId);
    
    if (error) {
      Utils.showToast('Errore nell\'aggiornamento', 'error');
      return;
    }
    
    // Reload to update score
    this.render(guyId);
  }
};

window.GuyDetail = GuyDetail;
